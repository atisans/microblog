# Microblog API

A RESTful API backend for the Microblog project, built with Go, chi router, and SQLite.

## Getting Started

Make sure you're in the `api/` directory, fetch dependencies with `go mod tidy`, then run the application:

```bash
go mod tidy
go run ./cmd/api
```

If you make a request to the `GET /status` endpoint, you should get a response like this:

```bash
$ curl -i http://localhost:5000/status
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 18

{"status":"OK"}
```

For live reload support during development, use the Makefile:

```bash
make run/live
```

## Configuration

Configuration is managed via environment variables. Copy `.env.example` to `.env` and customize as needed:

```bash
cp .env.example .env
```

Required environment variables:

| Variable | Default | Description |
| --- | --- | --- |
| `PORT` | `5000` | HTTP server port |
| `DATABASE_URL` | `./microblog.db?_foreign_keys=on` | SQLite database file path |
| `JWT_SECRET_KEY` | (required) | Secret key for signing JWT tokens |

Edit the `run()` function in `cmd/api/main.go` to add or modify configuration parsing.

## Project Structure

| Path | Purpose |
| --- | --- |
| `cmd/api/` | Application entry point and HTTP handlers |
| `cmd/api/main.go` | Server initialization and configuration |
| `cmd/api/routes.go` | Route definitions |
| `cmd/api/handlers.go` | HTTP request handlers |
| `cmd/api/middleware.go` | Custom middleware |
| `cmd/api/errors.go` | Error handling helpers |
| `cmd/api/helpers.go` | Utility functions |
| `cmd/api/server.go` | Server startup/shutdown |
| `internal/database/` | Database connection and queries |
| `internal/auth/` | Authentication and JWT utilities |
| `internal/request/` | Request parsing helpers |
| `internal/response/` | JSON response helpers |
| `internal/validator/` | Validation utilities |
| `migrations/` | Database schema migrations (goose) |
| `queries/` | SQL queries (generated by sqlc) |

## API Endpoints
2
### Status
- **GET** `/status` - Health check endpoint
  - Response: `{"status":"OK"}`

### Authentication
- **POST** `/api/v1/auth/token` - User login
  - Request: `{"username":"string","password":"string"}`
  - Response: `{"data":{"token":"jwt_token_string"}}`

### Users
- **POST** `/api/v1/users` - User registration
  - Request: `{"username":"string","password":"string","email":"string"}`
  - Response: User object with id, username, email

## Database

SQLite3 with the [mattn/go-sqlite3](https://github.com/mattn/go-sqlite3) driver.

Database file is stored at the path specified in `DATABASE_URL`, typically `./microblog.db`.

The codebase uses the standard library `database/sql` with [sqlc](https://sqlc.dev/) for generating type-safe SQL queries and [goose](https://github.com/pressly/goose) for database migrations.

### Migrations

Run migrations using goose:

```bash
make db/migrate        # Run all pending migrations
make db/status         # Check migration status
make db/up             # Run one migration
make db/down           # Rollback one migration
make db/reset          # Reset all migrations (dangerous!)
make db/create NAME=my_migration  # Create a new migration
```

Migrations are defined in the `migrations/` directory as `.sql` files.

## Creating Handlers

Handlers are defined as methods on the `application` struct in `cmd/api/handlers.go`:

```go
func (app *application) myHandler(w http.ResponseWriter, r *http.Request) {
    // Handler logic
    err := response.JSON(w, http.StatusOK, data)
    if err != nil {
        app.serverError(w, r, err)
    }
}
```

Register the handler in `cmd/api/routes.go`:

```go
v1Router.Get("/api/v1/my-endpoint", app.myHandler)
```

## Middleware

Middleware is defined in `cmd/api/middleware.go`. They follow the standard chi pattern:

```go
func (app *application) myMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Middleware logic
        next.ServeHTTP(w, r)
    })
}
```

Register middleware in `routes()`:

```go
v1Router.Use(app.myMiddleware)
```

Or for specific routes using route groups:

```go
v1Router.Group(func(router chi.Router) {
    router.Use(app.myMiddleware)
    router.Get("/protected", app.protectedHandler)
})
```

## Request/Response Helpers

### Parsing JSON requests

```go
var input struct {
    Username string `json:"username"`
    Email    string `json:"email"`
}

err := request.DecodeJSON(w, r, &input)
if err != nil {
    app.badRequest(w, r, err)
    return
}
```

### Sending JSON responses

```go
data := map[string]string{"message": "success"}
err := response.JSON(w, http.StatusOK, data)
if err != nil {
    app.serverError(w, r, err)
}
```

### With custom headers

```go
headers := make(http.Header)
headers.Set("X-Custom-Header", "value")
err := response.JSONWithHeaders(w, http.StatusOK, data, headers)
```

## Validation

The `internal/validator` package provides validation helpers:

```go
v := validator.New()
v.CheckField(input.Username != "", "username", "Username is required")
v.CheckField(validator.NotBlank(input.Email), "email", "Email is required")
v.CheckField(validator.IsEmail(input.Email), "email", "Email is invalid")

if v.HasErrors() {
    app.failedValidation(w, r, v)
    return
}
```

Available helpers:
- `NotBlank(s string)` - Non-empty string check
- `MinRunes(s string, n int)` - Minimum character count
- `MaxRunes(s string, n int)` - Maximum character count
- `Between(v, min, max T)` - Range check
- `In(v T, safelist ...T)` - Value in list
- `IsEmail(s string)` - Email format validation
- `IsURL(s string)` - URL format validation
- `Matches(s string, rx *regexp.Regexp)` - Regex match

## Authentication

JWT token generation and validation:

```go
import "microblog/internal/auth"

// Generate token
token, err := auth.GenerateToken(userID, app.config.jwtSecret)

// Validate token
userID, err := auth.ValidateToken(token, app.config.jwtSecret)
```

## Logging

Structured logging via `log/slog`:

```go
app.logger.Info("user created", "user_id", userID)
app.logger.Error("database error", "err", err)
```

Logs are output as JSON to stdout. Configure log level in `cmd/api/main.go`.

## Background Tasks

Run async tasks using the helper in `cmd/api/helpers.go`:

```go
app.backgroundTask(r, func() error {
    // Long-running operation
    return sendEmail(user.Email)
})
```

The server will wait for background tasks to complete during graceful shutdown.

## Admin Tasks

From the `api/` directory:

| Command | Purpose |
| --- | --- |
| `make tidy` | Format code with `go fmt` and tidy `go.mod` |
| `make audit` | Run `go vet`, security checks, and tests |
| `make test` | Run all tests |
| `make test/cover` | Generate test coverage report |
| `make build` | Build binary to `/tmp/bin` |
| `make run` | Build and run binary |
| `make run/live` | Run with live reload (watches `.go`, `.sql`, etc.) |

## Live Reload

When using `make run/live`, the application automatically rebuilds and restarts on changes to:
- `.go` - Go source files
- `.sql` - SQL files
- `.tpl`, `.tmpl`, `.html` - Template files
- Images and CSS

Configured via `Makefile` using the [cosmtrek/air](https://github.com/cosmtrek/air) tool.

## Graceful Shutdown

The server listens for OS signals (SIGINT, SIGTERM) and gracefully shuts down, allowing:
- In-flight requests to complete
- Background tasks to finish
- Database connections to close cleanly

## Error Handling

Standard error responses:

- `400 Bad Request` - Invalid input or JSON parsing error
- `401 Unauthorized` - Authentication failed
- `404 Not Found` - Endpoint not found
- `405 Method Not Allowed` - HTTP method not supported
- `422 Unprocessable Entity` - Validation error
- `500 Internal Server Error` - Server error

Error responses include a message and optional field-level errors:

```json
{
    "message": "validation error",
    "FieldErrors": {
        "username": "Username is required",
        "email": "Email is invalid"
    }
}
```
